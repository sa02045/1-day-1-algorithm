# 외판원 문제

1. 경로를 비트로 표현
2. dp로 메모이제이션
3. 재귀 + dfs로 탐색

## 포인트

1. 출발 도시는 중요하지 않음

- `순한경로`를 이루기 때문에

2. dp에는 현재도시에서 남은 도시를 거쳐 출발점으로 돌아오는 비용

```py
dp[0][0011]
```

- 현재 0번 도시
- 0,1번 도시를 방문함
- 2,3번 도시를 방문한 후 다시 시작점으로 돌아갈 때 최소비용

```py
dp[cur][visited] = min(dp[cur][visited],dp[cur][next] + dp[next][visited | (1 << next)])
```
