# 병든 나이트

1. 가장 왼쪽아래에 위치 (N,0)
2. 조건

   - 이동횟수가 4번보다 적지않다면, 이동방법을 모두 한번씩 사용해야한다

3. 구하는 것
   - 병든 나이트가 여행에서 `방문할 수 있는 칸`의 개수중 최댓값을 출력

# 문제풀이 전략

1. 무조건 오른쪽으로 이동해야함
   - bfs로 이동?
2. 4번까지는 아무렇게 이동해도 상관없음
3. 5번부터 이동하려면 이동하지 않았던 방법을 사용해야함

# 문제풀이 결론

BFS가 아닌 케이스 분류로 풀어야한다!!!

1. Case M,N이 충분히 클 때)
   세로는 위아래로 움직일 수 있으니 가로만 신경쓰면 된다!

   - 가로의 길이가 7이상이고 세로의 길이가 3이상이면 이동방법으로 1번씩 이동하고 (가로 7위치), (2,1)(-2,1)을 반복하면 된다. 만역 남은 길이가 4라면 4번새로운 위치에 위치할 수 있음
   - 처음위치 (1) + 디폴드이동 4번(7) + (2,1)(-2,1)반복
   - 결론 ) 5 + M-7

2. Case 세로가 1일때)
   - 움직일 수 없으니 원래 위치 1군데
   - 결론 )1
3. Case 세로가 2일때)

   - (2,1)(-2,1)로는 움직일 수 없으니 (1,2)(-1,2)로만 움직여야함 == 4번못움직임=3번움직여야함 즉, 최대 결론)4 하지만 가로도 따져줘야함
   - 가로길이가 2면 1번, 3이면 2번 4이상이면 3번 움직일 수 있음
   - 결론) 4 or (M+1)/2 중 작은 값

4. Case 가로가 7미만일떄)
   - 7미만이면 모든 경우에 대해 한번 씩 움직일 수 없음 => 최대 4
   - 결론 ) 4 또는 M중 최솟값
